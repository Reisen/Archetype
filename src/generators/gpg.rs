use crate::crypto::SecretGenerator;
use std::error::Error;
use url::Url;

type Result<T> = std::result::Result<T, Box<dyn Error>>;

#[derive(Debug)]
pub struct GeneratedMaterial {
    pub input_key: Vec<u8>,
    pub subkeys:   Vec<Vec<u8>>,
}

/// Crappy helper to pull arguments out of a Url.
fn get_query(url: &Url, arg: &str) -> Result<String> {
    url.query_pairs()
        .find(|x| (*x).0 == arg)
        .map(|x| x.1)
        .ok_or_else(|| format!("Could not find argument: {}", arg).into())
        .map(|s| s.to_string())
}

/// Generate a GPG key containing ed25519 subkeys.
///
/// URI Format Example:
/// gpg://reisen@morphism.org?name=Reisen&count=2&year=2020
///
/// The key passed into this function will be the primary certificate key for
/// the resulting keyring. Each successive subkey is generated by hashing a
/// counter using the certificate key.
///
/// Decisions made about the keys generated by this file:
///
/// 1) Packet ordering is grouped with critical below.
/// 2) Subkeys do not generate with expirations, they can be added.
pub fn create_gpg_key(
    url: Url,
    mut gen: SecretGenerator,
    print: bool,
) -> Result<GeneratedMaterial> {
    // Pull in all Sequoia Dependencies
    use sequoia_openpgp::cert::Cert;
    use sequoia_openpgp::packet::key::Key4;
    use sequoia_openpgp::packet::{signature, Key, UserID};
    use sequoia_openpgp::serialize::Serialize;
    use sequoia_openpgp::types::{
        CompressionAlgorithm,
        Features,
        HashAlgorithm,
        KeyFlags,
        SignatureType,
        SymmetricAlgorithm,
    };

    // Everything Else
    use chrono::prelude::{TimeZone, Utc};
    use std::{io::stdout, time};

    // Get either username@domain, or username if no domain.
    let authority = url
        .domain()
        .map(|domain| format!("{}@{}", url.username(), domain))
        .unwrap_or_else(|| url.username().into());

    // Track the resulting subkeys, used to track generated subkeys throughout
    // this function, which are then appended to the final key.
    let mut subkeys = Vec::new();

    // Do extraction of arguments for generation
    // -------------------------------------------------------------------------
    let name: &str = &*get_query(&url, "name")?;
    let count: u32 = get_query(&url, "count")?.parse()?;
    let year: i32 = get_query(&url, "year")?.parse()?;

    // Generate Secret Key Material
    //
    // NOTE: We want to input the full fixed block size into hmac256, so that we
    // can be sure there's no weird extension going on that we can't replicate
    // in some other hmac implementation.
    //
    // TODO: Add test for this.
    // -------------------------------------------------------------------------
    let key = gen.get_bytes(32);
    let now: time::SystemTime = Utc.ymd(year, 1, 1).and_hms(0, 0, 0).into();
    let secret = Key4::import_secret_ed25519(&key, now)?;
    let mut keypair = secret.clone().into_keypair()?;
    let flags = KeyFlags::default().set_certification(true);

    // Key Preferences
    // -------------------------------------------------------------------------
    let hash_preferences = vec![
        HashAlgorithm::SHA512,
        HashAlgorithm::SHA384,
        HashAlgorithm::SHA256,
    ];

    let zip_preferences = vec![
        CompressionAlgorithm::Zlib,
        CompressionAlgorithm::BZip2,
        CompressionAlgorithm::Zip,
    ];

    let crypto_preferences = vec![
        SymmetricAlgorithm::AES256,
        SymmetricAlgorithm::Twofish,
        SymmetricAlgorithm::AES192,
        SymmetricAlgorithm::AES128,
    ];

    // Generate Packets
    // -------------------------------------------------------------------------
    let packet_key = Key::V4(secret);
    let packet_uid =
        UserID::from_address(Some(name.to_string()), None, authority)?;
    let packet_sig =
        signature::Builder::new(SignatureType::PositiveCertification)
            .set_features(&Features::sequoia())?
            .set_issuer_fingerprint(packet_key.fingerprint())?
            .set_issuer(packet_key.keyid())?
            .set_preferred_compression_algorithms(zip_preferences)?
            .set_preferred_hash_algorithms(hash_preferences.clone())?
            .set_preferred_symmetric_algorithms(crypto_preferences)?
            .set_hash_algo(HashAlgorithm::SHA512)
            .set_key_flags(&flags)?
            .set_primary_userid(true)?
            .set_signature_creation_time(now)?
            .sign_userid_binding(&mut keypair, &packet_key, &packet_uid)?;

    // Create Certificate from Packets
    // -------------------------------------------------------------------------
    let mut packets = vec![
        packet_key.clone().into(),
        packet_uid.into(),
        packet_sig.into(),
    ];

    // With our Certificate, begin generating N Signing/Authentication Subkeys
    // to attach to the certificate. We hash the initial secret key repeatedly
    // to get each successive ed25519 secret key.
    // -------------------------------------------------------------------------
    for _ in 0 .. count {
        {
            let key = gen.get_bytes(32);
            let key = key.as_slice();
            subkeys.push(key.to_vec());

            // Extract Key Bytes
            let flags = KeyFlags::default()
                .set_authentication(true)
                .set_signing(true);

            // Generate Subkeys
            let sub_secret = Key4::import_secret_ed25519(key, now)?;
            let mut sub_keypair = sub_secret.clone().into_keypair()?;
            let packet_sub = Key::V4(sub_secret);

            // We need to generate a cross signature. This is a signature that
            // signs the original certificate primary key, this way we end up
            // with:
            //    Primary -> Subkey
            //    Subkey  -> Primary
            let packet_crs =
                signature::Builder::new(SignatureType::PrimaryKeyBinding)
                    .set_hash_algo(HashAlgorithm::SHA512)
                    .set_signature_creation_time(now)?
                    .set_issuer_fingerprint(packet_sub.fingerprint())?
                    .set_issuer(packet_sub.keyid())?
                    .sign_primary_key_binding(
                        &mut sub_keypair,
                        &packet_key,
                        &packet_sub,
                    )?;

            // Generate Signature for Subkey
            let packet_sig =
                signature::Builder::new(SignatureType::SubkeyBinding)
                    .set_features(&Features::sequoia())?
                    .set_hash_algo(HashAlgorithm::SHA512)
                    .set_issuer_fingerprint(packet_key.fingerprint())?
                    .set_issuer(packet_key.keyid())?
                    .set_preferred_hash_algorithms(hash_preferences.clone())?
                    .set_embedded_signature(packet_crs)?
                    .set_key_flags(&flags)?
                    .set_signature_creation_time(now)?
                    .sign_subkey_binding(
                        &mut keypair,
                        &packet_key,
                        &packet_sub,
                    )?;

            packets.extend(vec![packet_sub.into(), packet_sig.into()]);
        }

        {
            let mut key = gen.get_bytes(32);
            let key = key.as_mut_slice();
            subkeys.push(key.to_vec());

            // Perform Curve25519 Manipulations
            key[0] &= 248;
            key[31] &= 63;
            key[31] |= 64;

            let flags = KeyFlags::default()
                .set_storage_encryption(true)
                .set_transport_encryption(true);

            // Generate Subkeys
            let sub_secret = Key4::import_secret_cv25519(
                key,
                HashAlgorithm::SHA512,
                SymmetricAlgorithm::AES256,
                now,
            )?;
            let packet_sub = Key::V4(sub_secret);

            // Generate Signature for Subkey
            let packet_sig =
                signature::Builder::new(SignatureType::SubkeyBinding)
                    .set_features(&Features::sequoia())?
                    .set_hash_algo(HashAlgorithm::SHA512)
                    .set_issuer_fingerprint(packet_key.fingerprint())?
                    .set_issuer(packet_key.keyid())?
                    .set_preferred_hash_algorithms(hash_preferences.clone())?
                    .set_key_flags(&flags)?
                    .set_signature_creation_time(now)?
                    .sign_subkey_binding(
                        &mut keypair,
                        &packet_key,
                        &packet_sub,
                    )?;

            packets.extend(vec![packet_sub.into(), packet_sig.into()]);
        }
    }

    if print {
        let certificate = Cert::from_packet_pile(packets.into())?;
        let _ = certificate.as_tsk().serialize(&mut stdout());
    }

    Ok(GeneratedMaterial {
        input_key: key.to_vec(),
        subkeys,
    })
}

#[cfg(test)]
mod testing {
    use super::*;

    #[test]
    fn test_expected_keys() {
        // Generate a known Argon2id master key
        use argon2::{hash_raw, Config, ThreadMode, Variant, Version};
        use hex::encode;

        // TODO: Come up with better configuration defaults.
        let config = &Config {
            ad:          &[],
            hash_length: 64,
            lanes:       2,
            mem_cost:    1024,
            secret:      &[],
            thread_mode: ThreadMode::Parallel,
            time_cost:   2,
            variant:     Variant::Argon2id,
            version:     Version::Version13,
        };

        let key =
            hash_raw("password".as_bytes(), "password".as_bytes(), config)
                .unwrap();

        // Define Test Keys
        let (m, a, b, c, e, f) = (
            "868641b9b683a0a39b60cd851b0169e234f0c0cc1554a7852f4adbbcca8c12474aa8f71f91a2445c44abb98a55b43747cd0806af475170cabe6584a11868ef0e",
            "08d1d44c8152fff493406b49778f9b2e2b066e211fbba633f0dd3503d8d3008b",
            "fc69c8b9bbb40a2e29f58765ad221f7902a6b747320b371da339505cc8e5af8e",
            "f7798721034f3dff33f741b40b92aecd22ec38004437366fd949589b1cdcb735",
            "75e6da4064a425bb451d2af739190487c778197dc3312da92de6fd06a7d16dcd",
            "0125348b2420cea50678ad8e0abb46d8b3f996420ddde16ab0b8fe9f90b92aec",
        );

        // Ensure that we get the expected key material for our Argon2id inputs.
        assert_eq!(encode(&key), m);

        let gen = SecretGenerator::new(
            &key,
            "gpg://test@test.com?name=Test&count=2&year=2020",
        );

        // Generate a GPG Key
        let material = create_gpg_key(
            "gpg://test@test.com?name=Test&count=2&year=2020"
                .parse()
                .unwrap(),
            gen,
            false,
        )
        .unwrap();

        // Check Generated Keys are what we expect.
        assert_eq!(material.subkeys.len(), 4);
        assert_eq!(encode(material.input_key), a);
        assert_eq!(encode(material.subkeys.get(0).unwrap()), b);
        assert_eq!(encode(material.subkeys.get(1).unwrap()), c);
        assert_eq!(encode(material.subkeys.get(2).unwrap()), e);
        assert_eq!(encode(material.subkeys.get(3).unwrap()), f);
    }
}
