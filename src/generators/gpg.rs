use std::error::Error;
use url::Url;

pub struct GeneratedMaterial {
    pub input_key: Vec<u8>,
    pub subkeys:   Vec<Vec<u8>>,
}

fn get_query(url: &Url, arg: &str) -> Result<String, Box<dyn Error>> {
    url.query_pairs()
        .find(|x| (*x).0 == arg)
        .map(|x| x.1)
        .ok_or(format!("Could not find argument: {}", arg).into())
        .map(|s| s.to_string())
}

/// Generate a GPG key containing ed25519 subkeys.
///
/// URI Format Example:
/// gpg://reisen@morphism.org?name=Reisen&count=8&year=2020
///
/// The key passed into this function will be the primary certificate key for
/// the resulting keyring. Each successive subkey is generated by hashing a
/// counter using the certificate key.
///
/// Decisions made about the keys generated by this file:
///
/// 1) Packet ordering is grouped with critical below.
/// 2) Subkeys do not generate with expirations, they can be added.
pub fn generate_gpg_key(
    url: Url,
    seed: &[u8],
    print: bool,
) -> Result<GeneratedMaterial, Box<dyn std::error::Error>> {
    use chrono::prelude::{TimeZone, Utc};
    use hmac::{Hmac, Mac};
    use sequoia_openpgp::cert::Cert;
    use sequoia_openpgp::packet::key::Key4;
    use sequoia_openpgp::packet::{signature, Key, UserID};
    use sequoia_openpgp::serialize::Serialize;
    use sequoia_openpgp::types::{
        CompressionAlgorithm,
        Features,
        HashAlgorithm,
        KeyFlags,
        SignatureType,
        SymmetricAlgorithm,
    };
    use sha2::Sha256;
    use std::{io::stdout, time};

    let authority = format!("{}@{}", url.username(), url.domain().unwrap());
    let mut subkeys = Vec::new();

    // Do extraction of arguments for generation
    // -------------------------------------------------------------------------
    let name: &str = &*get_query(&url, "name")?;
    let count: u64 = get_query(&url, "count")?.parse()?;
    let year: i32 = get_query(&url, "year")?.parse()?;

    // Generate Secret Key Material
    // -------------------------------------------------------------------------
    let key = {
        let mut key = Hmac::<Sha256>::new_varkey(seed).unwrap();
        key.input(&0u64.to_be_bytes());
        key.result().code()
    };

    let now: time::SystemTime = Utc.ymd(year, 1, 1).and_hms(0, 0, 0).into();
    let secret = Key4::import_secret_ed25519(&key, now)?;
    let mut keypair = secret.clone().into_keypair()?;
    let flags = KeyFlags::default().set_certification(true);

    // Key Preferences
    // -------------------------------------------------------------------------
    let hash_preferences = vec![
        HashAlgorithm::SHA512,
        HashAlgorithm::SHA384,
        HashAlgorithm::SHA256,
    ];

    let zip_preferences = vec![
        CompressionAlgorithm::Zlib,
        CompressionAlgorithm::BZip2,
        CompressionAlgorithm::Zip,
    ];

    let crypto_preferences = vec![
        SymmetricAlgorithm::AES256,
        SymmetricAlgorithm::Twofish,
        SymmetricAlgorithm::AES192,
        SymmetricAlgorithm::AES128,
    ];

    // Generate Packets
    // -------------------------------------------------------------------------
    let packet_key = Key::V4(secret);
    let packet_uid =
        UserID::from_address(Some(name.to_string()), None, authority)?;
    let packet_sig =
        signature::Builder::new(SignatureType::PositiveCertification)
            .set_features(&Features::sequoia())?
            .set_issuer_fingerprint(packet_key.fingerprint())?
            .set_issuer(packet_key.keyid())?
            .set_preferred_compression_algorithms(zip_preferences)?
            .set_preferred_hash_algorithms(hash_preferences.clone())?
            .set_preferred_symmetric_algorithms(crypto_preferences)?
            .set_hash_algo(HashAlgorithm::SHA512)
            .set_key_flags(&flags)?
            .set_primary_userid(true)?
            .set_signature_creation_time(now)?
            .sign_userid_binding(&mut keypair, &packet_key, &packet_uid)?;

    // Create Certificate from Packets
    // -------------------------------------------------------------------------
    let mut certificate = Cert::from_packet_pile(
        vec![
            packet_key.clone().into(),
            packet_uid.into(),
            packet_sig.into(),
        ]
        .into(),
    )?;

    // With our Certificate, begin generating N Signing/Authentication Subkeys
    // to attach to the certificate. We hash the initial secret key repeatedly
    // to get each successive ed25519 secret key.
    // -------------------------------------------------------------------------
    for n in 1u64 .. count + 1 {
        let key = {
            let mut key = Hmac::<Sha256>::new_varkey(&seed).unwrap();
            key.input(&n.to_be_bytes());
            key.result().code()
        };

        subkeys.push(key.clone().as_slice().to_vec());

        // Extract Key Bytes
        let key = key.as_slice();
        let flags = KeyFlags::default()
            .set_authentication(true)
            .set_signing(true);

        // Generate Subkeys
        let sub_secret = Key4::import_secret_ed25519(key, now)?;
        let mut sub_keypair = sub_secret.clone().into_keypair()?;
        let packet_sub = Key::V4(sub_secret);

        // We need to generate a cross signature. This is a signature that
        // signs the original certificate primary key, this way we end up
        // with:
        //    Primary -> Subkey
        //    Subkey  -> Primary
        let packet_crs =
            signature::Builder::new(SignatureType::PrimaryKeyBinding)
                .set_hash_algo(HashAlgorithm::SHA512)
                .set_signature_creation_time(now)?
                .set_issuer_fingerprint(packet_sub.fingerprint())?
                .set_issuer(packet_sub.keyid())?
                .sign_primary_key_binding(
                    &mut sub_keypair,
                    &packet_key,
                    &packet_sub,
                )?;

        // Generate Signature for Subkey
        let packet_sig = signature::Builder::new(SignatureType::SubkeyBinding)
            .set_features(&Features::sequoia())?
            .set_hash_algo(HashAlgorithm::SHA512)
            .set_issuer_fingerprint(packet_key.fingerprint())?
            .set_issuer(packet_key.keyid())?
            .set_preferred_hash_algorithms(hash_preferences.clone())?
            .set_embedded_signature(packet_crs)?
            .set_key_flags(&flags)?
            .set_signature_creation_time(now)?
            .sign_subkey_binding(&mut keypair, &packet_key, &packet_sub)?;

        certificate = certificate
            .merge_packets(vec![packet_sub.into(), packet_sig.into()])?;
    }

    if print {
        let _ = certificate.as_tsk().serialize(&mut stdout());
    }

    Ok(GeneratedMaterial {
        input_key: key.to_vec(),
        subkeys,
    })
}

#[cfg(test)]
mod testing {
    use super::*;

    #[test]
    fn test_expected_keys() {
        // Generate a known Argon2id master key
        use argon2::{hash_raw, Config, ThreadMode, Variant, Version};
        use hex::encode;

        // TODO: Come up with better configuration defaults.
        let config = &Config {
            ad:          &[],
            hash_length: 32,
            lanes:       2,
            mem_cost:    1024,
            secret:      &[],
            thread_mode: ThreadMode::Parallel,
            time_cost:   2,
            variant:     Variant::Argon2id,
            version:     Version::Version13,
        };

        let key =
            hash_raw("password".as_bytes(), "password".as_bytes(), config)
                .unwrap();

        // Define Test Keys
        let (a, b, c, d) = (
            "8bc2770a759a457180a905978df61e880548b4add67b0108026445b16c913484",
            "84cbf4eae5ee9c7f730d69a8549f97a7a2cc78e9ab65c20aa8e94c6aca6c3e27",
            "b2b09a9d3b9428dd5bc3449a176e3b00f67eee40051e444f1c322c1d86626606",
            "25fd27f78f7afb57a20b86d1ee8aad5915f889696f29d4dde0286cb50bdd49ee",
        );

        // Ensure that we get the expected key material for our Argon2id inputs.
        assert_eq!(encode(&key), a);

        // Generate a GPG Key
        let material = generate_gpg_key(
            "gpg://test@test.com?name=Test&count=2&year=2020"
                .parse()
                .unwrap(),
            &key,
            false,
        )
        .unwrap();

        // Check Generated Keys are what we expect.
        assert_eq!(encode(material.input_key), b);
        assert_eq!(material.subkeys.len(), 2);
        assert_eq!(encode(material.subkeys.get(0).unwrap()), c);
        assert_eq!(encode(material.subkeys.get(1).unwrap()), d);
    }
}

// '84cbf4eae5ee9c7f730d69a8549f97a7a2cc78e9ab65c20aa8e94c6aca6c3e27'
